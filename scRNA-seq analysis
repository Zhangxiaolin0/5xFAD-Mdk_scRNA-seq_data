# Load required libraries
library(Seurat)
library(SeuratData)
library(dplyr)
library(data.table)
library(ggplot2)
library(ComplexHeatmap)
library(circlize)
library(tibble)
library(reshape2)
library(ggalluvial)
library(grid)

# ========================================================================
# 1. DATA LOADING AND PREPROCESSING
# ========================================================================

# Set data paths (modify according to your directory structure)
data_path_MDK <- "/path/to/MDK/data"
data_path_FAD <- "/path/to/FAD/data"

# Load 10X data
data.MDK <- Read10X(data_path_MDK)
data.FAD <- Read10X(data_path_FAD)

# Create Seurat objects
data.MDK <- CreateSeuratObject(counts = data.MDK, project = "MDK", 
                               min.cells = 3, min.features = 200)
data.FAD <- CreateSeuratObject(counts = data.FAD, project = "FAD", 
                               min.cells = 3, min.features = 200)

# Add sample metadata
data.MDK@meta.data$Sample <- "M-FAD"
data.FAD@meta.data$Sample <- "FAD"

# ========================================================================
# 2. QUALITY CONTROL
# ========================================================================

# Merge datasets
data.combined <- merge(x = data.MDK, y = data.FAD)

# Calculate QC metrics
data.combined[["percent.mt"]] <- PercentageFeatureSet(data.combined, pattern = "^mt-")
data.combined[["percent.hb"]] <- PercentageFeatureSet(data.combined, pattern = "^Hbb-")

# Visualize QC metrics (optional, comment out for final version)
# VlnPlot(data.combined, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.hb"), 
#         ncol = 2, pt.size = 0.5)
# FeatureScatter(data.combined, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

# Apply QC filters (thresholds based on 5th and 95th percentiles)
data.combined.qc <- subset(data.combined, 
                           subset = nFeature_RNA > 927 & nFeature_RNA < 4641 &
                                    nCount_RNA > 1815 & nCount_RNA < 21193 & 
                                    percent.mt < 15)

# ========================================================================
# 3. NORMALIZATION AND FEATURE SELECTION
# ========================================================================

# Split by sample for independent processing
data.list <- SplitObject(object = data.combined.qc, split.by = "Sample")

# Normalize and select variable features for each sample
for (i in 1:length(data.list)) {
  # Log-normalize
  data.list[[i]] <- NormalizeData(object = data.list[[i]], 
                                  normalization.method = "LogNormalize")
  
  # Find variable features
  vst_data <- FindVariableFeatures(object = data.list[[i]]@assays$RNA@data, 
                                   selection.method = "vst", 
                                   nfeatures = 2000)
  
  # Filter by expression criteria
  vst_data <- vst_data[order(vst_data$vst.variance, decreasing = TRUE), ]
  vst_data <- vst_data[vst_data$vst.mean >= 0.1 & vst_data$vst.mean <= 8 & 
                       vst_data$vst.variance >= 0.5, ]
  
  # Update variable features
  data.list[[i]]@assays$RNA@var.features <- rownames(vst_data)
}

# ========================================================================
# 4. DATA INTEGRATION
# ========================================================================

# Find integration anchors
integration.anchors <- FindIntegrationAnchors(object.list = data.list, 
                                             dims = 1:50, 
                                             anchor.features = 2000)

# Integrate data
data.integrated <- IntegrateData(anchorset = integration.anchors, dims = 1:50)

# Clean up memory
rm(integration.anchors, data.list, data.MDK, data.FAD, data.combined, data.combined.qc)

# ========================================================================
# 5. DIMENSIONALITY REDUCTION
# ========================================================================

DefaultAssay(data.integrated) <- "integrated"

# Scale data
data.integrated <- ScaleData(object = data.integrated, 
                             features = data.integrated@assays$integrated@var.features)

# Run PCA
data.integrated <- RunPCA(object = data.integrated, npcs = 50)

# Run UMAP
data.integrated <- RunUMAP(object = data.integrated, 
                           reduction = "pca", 
                           dims = 1:15, 
                           check_duplicates = FALSE)

# ========================================================================
# 6. CLUSTERING
# ========================================================================

# Find neighbors and clusters
data.integrated <- FindNeighbors(object = data.integrated, 
                                reduction = "pca", 
                                dims = 1:15, 
                                k.param = 30)
data.integrated <- FindClusters(object = data.integrated, 
                               resolution = 1)

# Adjust cluster identities (convert to factor starting from 1)
cluster_idents <- as.integer(data.integrated@active.ident)
cluster_idents <- factor(cluster_idents, 
                        levels = 1:length(unique(cluster_idents)))
names(cluster_idents) <- rownames(data.integrated@meta.data)
data.integrated@active.ident <- cluster_idents
data.integrated@meta.data$Cluster <- cluster_idents

# ========================================================================
# 7. CELL TYPE ANNOTATION
# ========================================================================

# Annotate cell types based on marker genes
FeaturePlot(data.integrated, features = c("Cd3e", "Cd14",'Clec9a', 'S100a8'), label = T,
            reduction = 'umap', cols = c("lightgrey", "red"), min.cutoff = 0)

# HOM markers
FeaturePlot(data.integrated, features = c("Tmem119", "P2ry12", "Cx3cr1", "Csf1r", "C1qc", "Sall1"),
            label = F, pt.size = 1,
            reduction = 'umap', cols = c("lightgrey", "red"), min.cutoff = 0)

# DAM markers
FeaturePlot(data.integrated, features = c("Tmem119", "P2ry12", "Apoe", 
           "Spp1", "Trem2", "Cst7", "B2m", "Cstb", "Cstd", "Fth1"), label = T,
            reduction = 'umap', cols = c("lightgrey", "red"), min.cutoff = 0)

# lipid-processing microglia markers
FeaturePlot(data.integrated, features = c("Myo1e", "Ptprg"), label = T,
            reduction = 'umap', cols = c("lightgrey", "red"), min.cutoff = 0)

# phagocytic microglia markers
FeaturePlot(data.integrated, features = c("Cd163", "F13a1"), label = T,
            reduction = 'umap', cols = c("lightgrey", "red"), min.cutoff = 0)

# Mrc1+ microglia markers
FeaturePlot(data.integrated, features = c("Mrc1", "Cd74", "Lyz2", "Axl"), label = T,
            reduction = 'umap', cols = c("lightgrey", "red"), min.cutoff = 0)

Idents(data.integrated) <- data.integrated$Cluster
data.integrated <- RenameIdents(data.integrated, 
                               '1' = "DAM-1", '2' = "DAM-1", '3' = "DAM-1",
                               '4' = "HOM", '5' = "HOM", '6' = "Lipid Processing",
                               '7' = "DAM-2", '8' = "HOM", '9' = "T cell",
                               '10' = "Lipid Processing", '11' = "Phagocytic", 
                               '12' = "DAM-1", '13' = 'HOM', 
                               '14' = 'Microglia Mrc1+', '15' = 'Macrophage',
                               '16' = 'DC', '17' = 'Neutrophil', '18' = 'DC', 
                               '19' = 'DAM-2')

data.integrated$celltype <- Idents(data.integrated)

# Subset microglia populations only
Microglia.integrated <- subset(data.integrated, 
                              idents = c("HOM", 'DAM-1', "DAM-2", 'Phagocytic',
                                        "Lipid Processing", 'Microglia Mrc1+'))

# Set cell type order
levels(Microglia.integrated) <- c("HOM", "Lipid Processing", 'DAM-1', "DAM-2", 
                                 'Phagocytic', 'Microglia Mrc1+')
Microglia.integrated$celltype <- Idents(Microglia.integrated)

# ========================================================================
# 8. VISUALIZATION: UMAP
# ========================================================================

# Define color palette
my.color <- c("#006a8e", "#E39E3E", "#55967e", "#CC79A7", 
             "#D55E00", "#AF4034", "#EC6A5C", "#0072B2",
             '#6a60a9', "#fdc23e", "grey")

celltype.colors <- c(
  "HOM" = "#E39E3E",
  "Lipid Processing" = "#55967e",
  "DAM-1" = "#0072B2",
  "DAM-2" = "#CC79A7",
  "Phagocytic" = "#AF4034",
  "Microglia Mrc1+" = "#EC6A5C"
)

# UMAP plot by cell type
Idents(data.integrated) <- data.integrated$celltype
p1 <- DimPlot(object = data.integrated, 
             cols = my.color, 
             pt.size = 0.2,
             label = TRUE, 
             reduction = "umap",
             label.size = 5,
             repel = TRUE) +
  theme(text = element_text(family = "Arial"))

# UMAP plot split by sample
Idents(data.integrated) <- data.integrated$Sample
p2 <- DimPlot(object = data.integrated, 
             pt.size = 0.01, 
             reduction = 'umap', 
             label.size = 15,
             split.by = "Sample", 
             cols = c("#E73B37", '#30BBEA'))

# Visualize Mdk expression
p3 <- FeaturePlot(Microglia.integrated,
                 features = c("Mdk"),order = TRUE,min.cutoff = 0,reduction = "umap")

# ========================================================================
# 9. MARKER GENE HEATMAP
# ========================================================================

# Find marker genes for each cell type
celltype.markers <- FindAllMarkers(Microglia.integrated)
celltype.markers.sig <- subset(celltype.markers, 
                              p_val_adj < 0.05 & abs(avg_log2FC) > 0.5)

# Calculate average expression per cell type
celltype.avg.exp <- AverageExpression(Microglia.integrated, 
                                     assays = "RNA", 
                                     features = celltype.markers.sig$gene)
data <- as.data.frame(celltype.avg.exp$RNA)

# Prepare heatmap matrix
heatmap_matrix <- data %>%
  rownames_to_column("gene") %>%
  column_to_rownames("gene") %>%
  as.matrix()

# Sort genes by maximum expression cluster
max_col <- apply(heatmap_matrix, 1, which.max)
row_means <- rowMeans(heatmap_matrix)
sorted_order <- order(max_col, -row_means)
heatmap_matrix_sorted <- heatmap_matrix[sorted_order, ]

# Z-score normalization
heatmap_matrix_scaled <- t(scale(t(heatmap_matrix_sorted)))
heatmap_matrix_scaled[is.na(heatmap_matrix_scaled)] <- 0

# Reorder by cell type
desired_row_order <- c("HOM", "Lipid Processing", "DAM-1", 
                      "DAM-2", "Phagocytic", "Microglia Mrc1+")
heatmap_matrix_reordered <- t(heatmap_matrix_scaled)[desired_row_order, ]

# Final column ordering
max_row_per_gene <- apply(heatmap_matrix_reordered, 2, which.max)
max_value_per_gene <- apply(heatmap_matrix_reordered, 2, max)
col_order <- order(max_row_per_gene, -max_value_per_gene)
heatmap_matrix_final <- heatmap_matrix_reordered[, col_order]

# Define genes to label
genes_to_label <- c("Cx3cr1", "P2ry12", "Apoe", "Trem2", 'Cst7', "Axl", 
                   "Spp1", "Cd74", "Myo1e", "Ptprg", 'B2m', 'Ctsd', 'Ctsb',
                   "Cd163", "F13a1", "Tmem119", 'Fth1', 'Lyz2')

# Create heatmap annotations
gene_positions <- which(colnames(heatmap_matrix_final) %in% genes_to_label)
gene_names <- colnames(heatmap_matrix_final)[gene_positions]

col_anno <- HeatmapAnnotation(
  Genes = anno_mark(
    at = gene_positions,
    labels = gene_names,
    labels_gp = gpar(fontsize = 12, fontface = "bold", col = "black"),
    link_width = unit(10, "mm"),
    link_gp = gpar(lwd = 1.5, col = "black"),
    padding = unit(3, "mm"),
    side = "left"
  ),
  which = "column",
  show_annotation_name = FALSE
)

row_anno <- rowAnnotation(
  Type = rownames(heatmap_matrix_final),
  col = list(Type = celltype.colors),
  show_annotation_name = FALSE,
  show_legend = FALSE,
  width = unit(5, "mm")
)

# Define color scheme
col_fun <- colorRamp2(
  c(-2, -1.0, 0, 1.0, 2), 
  c("#2166ac", "#67a9cf", "white", "#ef8a62", "#b2182b")
)

# Create heatmap
ht <- Heatmap(
  heatmap_matrix_final,
  name = "Expression",
  col = col_fun,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  show_row_names = TRUE,
  row_names_gp = gpar(fontsize = 13, fontface = "bold", col = "black"),
  row_names_side = "left",
  row_title = NULL,
  show_column_names = FALSE,
  bottom_annotation = col_anno,
  left_annotation = row_anno,
  heatmap_legend_param = list(
    title = "Expression\n(Z-score)",
    title_gp = gpar(fontsize = 13, fontface = "bold"),
    labels_gp = gpar(fontsize = 11),
    legend_height = unit(6, "cm"),
    legend_width = unit(1, "cm"),
    legend_direction = "vertical",
    at = c(-2, -1.0, 0, 1.0, 2),
    labels = c("-2", "-1.0", "0", "1.0", "2"),
    border = "black",
    grid_width = unit(5, "mm")
  ),
  border = TRUE,
  border_gp = gpar(col = "black", lwd = 2),
  row_gap = unit(0.5, "mm"),
  column_gap = unit(0, "mm"),
  use_raster = TRUE,
  raster_quality = 10,
  raster_device = "png",
  width = unit(20, "cm"),
  height = unit(8, "cm")
)

# Save heatmap
pdf("Figure_microglia_markers_heatmap.pdf", width = 16, height = 7)
draw(ht, 
     heatmap_legend_side = "right",
     padding = unit(c(2, 2, 2, 10), "mm"))
dev.off()

# ========================================================================
# 10. CELL PROPORTION ANALYSIS AND ALLUVIAL PLOT
# ========================================================================

# Split by sample and calculate proportions
data.list.by.sample <- SplitObject(object = Microglia.integrated, split.by = "Sample")
FAD.cellnum <- prop.table(table(data.list.by.sample$FAD$celltype))
MDK.cellnum <- prop.table(table(data.list.by.sample$`M-FAD`$celltype))

# Merge proportion data
cellnum.df <- merge(data.frame(FAD.cellnum), 
                   data.frame(MDK.cellnum), 
                   by = 'Var1')
cellnum.df <- cellnum.df[order(cellnum.df$Var1), ]
names(cellnum.df) <- c("celltype", "FAD", "M-FAD")

# Convert to long format for plotting
cellnum.df.long <- melt(cellnum.df, 
                       id.vars = 'celltype', 
                       variable.name = 'sample', 
                       value.name = 'proportion')

# Set factor levels for ordering
cellnum.df.long$celltype <- factor(cellnum.df.long$celltype, 
                                   levels = rev(c("HOM", "Lipid Processing", "DAM-1", "DAM-2", 
                                                 "Phagocytic", "Microglia Mrc1+")))
cellnum.df.long$sample <- factor(cellnum.df.long$sample, 
                                levels = c("M-FAD", "FAD"))

# Define colors for alluvial plot
alluvial.colors <- c(
  "HOM" = "#E39E3E",
  "Lipid Processing" = "#55967e",
  "DAM-1" = "#0072B2",
  "DAM-2" = "#CC79A7",
  "Phagocytic" = "#AF4034",
  "Microglia Mrc1+" = "#EC6A5C"
)

# Create alluvial plot
p_alluvial <- ggplot(data = cellnum.df.long,
                    aes(x = sample, y = proportion, 
                        stratum = celltype, alluvium = celltype, fill = celltype)) +
  geom_alluvium(alpha = 0.5, width = 0.6, curve_type = "sigmoid") +
  geom_stratum(width = 0.6, color = "white", size = 0.8) +
  geom_text(stat = "stratum", 
           aes(label = ifelse(proportion > 0.05,
                             paste0(round(proportion*100, 1), "%"), 
                             "")), 
           size = 3.5, 
           fontface = "bold",
           color = "white") +
  scale_fill_manual(values = alluvial.colors) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                    expand = c(0, 0)) +
  theme_classic(base_size = 14, base_family = "Arial") +
  theme(
    axis.title = element_text(size = 16, face = "bold", color = "black"),
    axis.text.x = element_text(size = 14, color = "black", face = "bold"),
    axis.text.y = element_text(size = 12, color = "black"),
    axis.line = element_line(size = 1, color = "black"),
    axis.ticks = element_line(size = 0.8, color = "black"),
    axis.ticks.length = unit(0.2, "cm"),
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    legend.key.size = unit(0.8, "cm"),
    legend.position = "right",
    legend.background = element_rect(fill = "white", color = "black", size = 0.5),
    panel.background = element_rect(fill = "white"),
    plot.background = element_rect(fill = "white"),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  ) +
  coord_flip() +
  labs(y = "Proportion", 
       x = "Sample",
       fill = "Cell Type")

# Save alluvial plot
ggsave("Figure_cell_proportion_alluvial.pdf", 
       plot = p_alluvial, 
       width = 10, 
       height = 8)

# ========================================================================



# ========================================================================
# Phagocytic Microglia Signature Genes 
# ========================================================================
phago_genes <- c("Apoe", "Trem2", "B2m", "Ctsb", "Ctsd", "Cd68", "Lyz2")

phago_genes_exist <- phago_genes[phago_genes %in% rownames(Microglia.integrated)]

cat("========== Phagocytic Marker Genes ==========\n")
cat("Total genes:", length(phago_genes), "\n")
cat("Found genes:", length(phago_genes_exist), "\n")
if (length(phago_genes_exist) < length(phago_genes)) {
  missing <- setdiff(phago_genes, phago_genes_exist)
  cat("Missing genes:", paste(missing, collapse = ", "), "\n")
}
print(phago_genes_exist)
cat("\n")


cat("Sample groups in data:\n")
print(table(Microglia.integrated$Sample))
cat("\n")


SAMPLE1 <- "FAD"      
SAMPLE2 <- "M-FAD"  


plot_list <- list()

for (gene in phago_genes_exist) {
  
  cat("Processing gene:", gene, "\n")

  p <- VlnPlot(
    Microglia.integrated, 
    features = gene,
    split.by = "Sample",
    group.by = "Sample",
    pt.size = 0,           
    cols = c("#6BAED6", "#E74C3C") 
  ) +
    # 添加统计比较
    stat_compare_means(
      comparisons = list(c(SAMPLE1, SAMPLE2)),
      method = "wilcox.test",      
      label = "p.signif",          
      label.y.npc = 0.95,          
      size = 6,
      tip.length = 0.01
    ) +
    labs(
      title = gene,
      x = "",
      y = "Expression Level"
    ) +
    theme_classic(base_size = 12) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold.italic", size = 14),
      legend.position = "none",
      axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10),
      axis.text.y = element_text(size = 10),
      axis.title.y = element_text(size = 11, face = "bold")
    )
  
  plot_list[[gene]] <- p
}


panel_D <- wrap_plots(plot_list, ncol = 4, nrow = 2)

print(panel_D)


ggsave(
  "phagocytic_markers.pdf", 
  panel_D, 
  width = 12, 
  height = 8,
  dpi = 300
)









# ========================================================================
# Trajectory Analysis of DAM Populations using Monocle3
# ========================================================================
set.seed(42)
# ============================================================

library(monocle3)
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
library(clusterProfiler)
library(org.Mm.eg.db)
library(enrichplot)

cat("\n========== Software Versions ==========\n")
cat("R version:", R.version.string, "\n")
cat("Monocle3:", as.character(packageVersion("monocle3")), "\n")
cat("Seurat:", as.character(packageVersion("Seurat")), "\n")
cat("Date:", Sys.Date(), "\n\n")
# ===========================================================

# ========================================================================
# 1. EXTRACT DAM CELLS FROM INTEGRATED DATA
# ========================================================================

# Subset DAM populations (DAM-1 and DAM-2)
DAM.integrated <- subset(Microglia.integrated, 
                         idents = c('DAM-1', "DAM-2"))

cat("========== DAM Cell Counts ==========\n")
table(Idents(DAM.integrated))


n_cells <- ncol(DAM.integrated)
cat("Total DAM cells:", n_cells, "\n")
if (n_cells < 50) {
  warning("Low cell count. Results may be unreliable.")
}
cat("\n")
# ===========================================================

# ========================================================================
# 2. CONVERT TO MONOCLE3 OBJECT
# ========================================================================

# Extract expression matrix (counts)
expression_matrix <- GetAssayData(DAM.integrated, 
                                  assay = "RNA", 
                                  slot = "counts")

# Cell metadata
cell_metadata <- DAM.integrated@meta.data

# Gene metadata
gene_metadata <- data.frame(
  gene_short_name = rownames(expression_matrix),
  row.names = rownames(expression_matrix)
)

# Create cell_data_set object
cds <- new_cell_data_set(
  expression_matrix,
  cell_metadata = cell_metadata,
  gene_metadata = gene_metadata
)

# ========================================================================
# 3. PREPROCESSING AND DIMENSIONALITY REDUCTION
# ========================================================================

# Preprocess data
cds <- preprocess_cds(cds, 
                      num_dim = 50,
                      method = "PCA",
                      norm_method = "log",
                      verbose = TRUE)

# UMAP dimension reduction
cds <- reduce_dimension(cds,
                        reduction_method = "UMAP",
                        preprocess_method = "PCA",
                        max_components = 2,
                        umap.n_neighbors = 30L,
                        umap.min_dist = 0.3,
                        verbose = TRUE)

# ========================================================================
# 4. CLUSTERING
# ========================================================================

# Perform Leiden clustering
cds <- cluster_cells(cds,
                     resolution = 0.0005,
                     k = 15,
                     cluster_method = "leiden",
                     random_seed = 42,
                     verbose = TRUE)

cat("\n========== Monocle3 Clustering Results ==========\n")
table(clusters(cds))
table(partitions(cds))

# ========================================================================
# 5. TRAJECTORY LEARNING
# ========================================================================

# Learn trajectory graph
cds <- learn_graph(cds, 
                   use_partition = FALSE,
                   close_loop = FALSE,
                   verbose = TRUE)

# Order cells along pseudotime
cds <- order_cells(cds)

# Add pseudotime and cluster info back to Seurat object
DAM.integrated$monocle3_cluster <- clusters(cds)[colnames(DAM.integrated)]
DAM.integrated$monocle3_partition <- partitions(cds)[colnames(DAM.integrated)]
DAM.integrated$pseudotime <- pseudotime(cds)[colnames(DAM.integrated)]

# ========================================================================
# 6. VISUALIZATION: DAM CLUSTERS
# ========================================================================

# Define color palette
nature_cols <- c("#B3D9E6", "#267399", "#4D99B3", "#D98FB3", "#B35C8F")

p_cluster <- plot_cells(cds,
                        color_cells_by = "cluster",
                        label_cell_groups = TRUE,
                        label_leaves = FALSE,
                        label_branch_points = FALSE,
                        graph_label_size = 0,
                        cell_size = 0.5) +
  scale_fill_manual(values = nature_cols) +
  ggtitle("DAM clusters") +
  theme_classic() +
  theme(legend.position = "right")

print(p_cluster)
ggsave("DAM_clusters.pdf", p_cluster, width = 8, height = 7)

# ========================================================================
# 7. VISUALIZATION: PSEUDOTIME
# ========================================================================

# Pseudotime visualization
p_pseudotime <- plot_cells(cds,
                           color_cells_by = "pseudotime",
                           label_cell_groups = FALSE,
                           label_leaves = FALSE,
                           label_branch_points = FALSE,
                           graph_label_size = 0,
                           cell_size = 0.5,
                           trajectory_graph_segment_size = 1) +
  scale_color_gradient(low = "white", high = "darkred") +
  ggtitle("Pseudotime") +
  theme_classic()

print(p_pseudotime)
ggsave("DAM_pseudotime.pdf", p_pseudotime, width = 8, height = 7)

# ========================================================================
# 8. VISUALIZATION: SAMPLE DISTRIBUTION
# ========================================================================

p_sample_split <- plot_cells(cds,
                             color_cells_by = "Sample",
                             label_cell_groups = FALSE,
                             label_leaves = TRUE,
                             label_branch_points = FALSE,
                             graph_label_size = 0,
                             cell_size = 0.5,
                             show_trajectory_graph = FALSE) +
  scale_color_manual(values = c("M-FAD" = "#E73B37", "FAD" = "#30BBEA")) +
  facet_wrap(~Sample) +
  ggtitle("Sample Comparison") +
  theme_classic() +
  theme(legend.position = "right")

print(p_sample_split)
ggsave("sample_distribution.pdf", p_sample_split, width = 12, height = 6)

# ========================================================================
# 9. CLUSTER 2 ANALYSIS
# ========================================================================

# Extract cluster 2 cells (corresponds to cluster 3 in code)
Idents(DAM.integrated) <- DAM.integrated$monocle3_cluster
cluster2_cells <- colnames(DAM.integrated)[Idents(DAM.integrated) == "3"]
cluster2_metadata <- DAM.integrated@meta.data[cluster2_cells, ]

DimPlot(DAM.integrated, 
        split.by = "orig.ident",
        cells.highlight = list(
          FAD = cluster2_cells[cluster2_cells %in% colnames(DAM.integrated[, DAM.integrated$orig.ident == "FAD"])],
          MDK = cluster2_cells[cluster2_cells %in% colnames(DAM.integrated[, DAM.integrated$orig.ident == "MDK"])]
        ),
        cols.highlight = c("#E64B35", "#4DBBD5"),
        cols = "grey90",
        pt.size = 0.25,
        sizes.highlight = 0.25) 


# Calculate sample distribution
cluster2_distribution <- cluster2_metadata %>%
  group_by(Sample) %>%
  summarise(count = n()) %>%
  mutate(percentage = count / sum(count) * 100)


cat("\n========== Cluster 2 Sample Distribution ==========\n")
print(cluster2_distribution)

# Pie chart of cluster 2 distribution
p_pie <- ggplot(cluster2_distribution, aes(x = "", y = percentage, fill = Sample)) +
  geom_col(width = 1, color = "white", size = 2) +
  coord_polar("y", start = 0) +
  geom_text(aes(label = paste0(round(percentage, 1), "%")),
            position = position_stack(vjust = 0.5),
            size = 8,
            fontface = "bold") +
  scale_fill_manual(values = c("M-FAD" = "#E74C3C", "FAD" = "#5DADE2")) +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12)
  ) +
  labs(title = "Cluster 2 Distribution", fill = "Sample")

print(p_pie)
ggsave("cluster2_distribution.pdf", p_pie, width = 8, height = 8)

# ========================================================================
# 10. MARKER GENE VISUALIZATION IN PSEUDOTIME
# ========================================================================

# Define marker genes
dam_markers <- c("Apoe", "Trem2", "Cst7")
hom_markers <- c("Cx3cr1", "P2ry12", "Tmem119")

# Filter existing genes
dam_markers_exist <- dam_markers[dam_markers %in% rownames(cds)]
hom_markers_exist <- hom_markers[hom_markers %in% rownames(cds)]

# Custom theme for gene expression plots
gene_plot_theme <- theme_classic(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank(),
    strip.background = element_rect(fill = "white", color = "black", size = 0.5),
    strip.text = element_text(size = 12, face = "bold.italic"),
    axis.line = element_line(color = "black", size = 0.5),
    axis.text = element_text(color = "black", size = 11),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "right",
    legend.background = element_rect(fill = "white", color = "black", size = 0.3),
    legend.title = element_text(size = 11, face = "bold"),
    legend.text = element_text(size = 10),
    plot.margin = margin(10, 10, 10, 10)
  )

# DAM markers in pseudotime
p_dam_genes <- plot_genes_in_pseudotime(cds[dam_markers_exist, ],
                                        color_cells_by = "pseudotime",
                                        min_expr = 0.1,
                                        ncol = 3,
                                        cell_size = 0.8) +
  scale_color_gradient(low = "white", high = "darkred") +
  gene_plot_theme +
  geom_smooth(method = "loess", color = "black", size = 1.2, 
              se = TRUE, alpha = 0.2)

print(p_dam_genes)
ggsave("DAM_markers_pseudotime.pdf", p_dam_genes, width = 12, height = 4)

# HOM markers in pseudotime
p_hom_genes <- plot_genes_in_pseudotime(cds[hom_markers_exist, ],
                                        color_cells_by = "pseudotime",
                                        min_expr = 0.1,
                                        ncol = 3,
                                        cell_size = 0.8) +
  scale_color_gradient(low = "white", high = "darkred") +
  gene_plot_theme +
  geom_smooth(method = "loess", color = "black", size = 1.2,
              se = TRUE, alpha = 0.2)

print(p_hom_genes)
ggsave("HOM_markers_pseudotime.pdf", p_hom_genes, width = 12, height = 4)

# ========================================================================
# 11. DIFFERENTIAL EXPRESSION: CLUSTER 2 vs OTHER DAM-1
# ========================================================================

# Find marker genes for cluster 2 (cluster 3 in original code)
Idents(DAM.integrated) <- "monocle3_cluster"

cluster2_markers <- FindMarkers(
  DAM.integrated,
  ident.1 = "3",
  ident.2 = c("1", "2"),
  min.pct = 0.25,
  logfc.threshold = 0.25
)

# Filter significant DEGs
cluster2_markers$change <- as.factor(
  ifelse(cluster2_markers$p_val_adj < 0.05 & abs(cluster2_markers$avg_log2FC) > 0.263,
         ifelse(cluster2_markers$avg_log2FC > 0.263, 'Up', 'Down'), 
         'Unsig')
)

cluster2_degs <- subset(cluster2_markers, 
                        abs(avg_log2FC) > 0.263 & p_val_adj < 0.05)

# Save results
write.csv(cluster2_degs, "Cluster2_vs_otherDAM1_DEGs.csv")

cat("\n========== Cluster 2 DEGs Summary ==========\n")
table(cluster2_degs$change)

# ========================================================================
# 12. HEATMAP OF TOP DEGs
# ========================================================================

# Select 25 up and down genes
top25_up <- cluster2_degs[order(cluster2_degs$avg_log2FC, decreasing = TRUE), ][1:25, ]
top25_down <- cluster2_degs[order(cluster2_degs$avg_log2FC, decreasing = FALSE), ][1:25, ]
top50_genes <- c(rownames(top25_up), rownames(top25_down))

# Calculate average expression
DefaultAssay(DAM.integrated) <- "RNA"
avg_expr <- AverageExpression(
  DAM.integrated,
  group.by = "monocle3_cluster",
  features = top50_genes,
  slot = "data"
)$RNA

# Select clusters of interest and order by cluster 2 expression
avg_expr_subset <- avg_expr[, c("1", "2", "3")]
avg_expr_subset <- avg_expr_subset[order(avg_expr_subset[, "Cluster 2"], 
                                         decreasing = FALSE), ]

# Z-score normalization
avg_expr_scaled <- t(scale(t(avg_expr_subset)))

# Color scheme
heatmap_colors <- colorRampPalette(c(
  "#2166AC", "#4393C3", "#92C5DE", "#D1E5F0", 
  "#F7F7F7", 
  "#FDDBC7", "#F4A582", "#D6604D", "#B2182B"
))(100)

# Create heatmap
library(pheatmap)

pdf("PanelH_cluster2_DEGs_heatmap.pdf", width = 5, height = 10)
tryCatch({
  pheatmap(
    avg_expr_scaled,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = TRUE,
    show_colnames = TRUE,
    color = heatmap_colors,
    border_color = NA,
    cellwidth = 50,
    cellheight = 8,
    fontsize = 12,
    fontsize_col = 14,
    fontsize_row = 8,
    angle_col = 0,
    main = "",
    gaps_col = c(1, 2),
    legend_breaks = c(-2, -1, 0, 1, 2),
    legend_labels = c("-2", "-1", "0", "1", "2")
  )
}, error = function(e) {
  cat("Error creating heatmap:", conditionMessage(e), "\n")
}, finally = {
  dev.off()
})
# ========================================================

# ========================================================================
# 13. GO ENRICHMENT ANALYSIS
# ========================================================================

# Separate up and down-regulated genes
up_genes <- rownames(cluster2_degs)[
  cluster2_degs$avg_log2FC > 0.263 & cluster2_degs$p_val_adj < 0.05
]

down_genes <- rownames(cluster2_degs)[
  cluster2_degs$avg_log2FC < -0.263 & cluster2_degs$p_val_adj < 0.05
]

# GO enrichment - upregulated genes
ego_up <- enrichGO(
  gene = up_genes,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2
)

# GO enrichment - downregulated genes
ego_down <- enrichGO(
  gene = down_genes,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2
)

# Save results
write.csv(as.data.frame(ego_up), "Cluster2_GO_upregulated.csv")
write.csv(as.data.frame(ego_down), "Cluster2_GO_downregulated.csv")

cat("\n========== GO Enrichment Summary ==========\n")
cat("Upregulated pathways:", nrow(as.data.frame(ego_up)), "\n")
cat("Downregulated pathways:", nrow(as.data.frame(ego_down)), "\n")

# ========================================================================
# 14. BARPLOT VISUALIZATION
# ========================================================================

# Prepare data for plotting (select top pathways manually or programmatically)

go_plot_data <- read.csv ("go_plot_data.csv")

# Modify count for plotting (negative for down-regulated)
go_plot_data$Count_plot <- ifelse(go_plot_data$regulation == "down", 
                                  -go_plot_data$Count, 
                                  go_plot_data$Count)

go_plot_data$fill_value <- ifelse(go_plot_data$regulation == "up",
                                  -log10(go_plot_data$pvalue),
                                  -(-log10(go_plot_data$pvalue)))

# Panel I: GO enrichment barplot
p_go <- ggplot(data = go_plot_data,
               aes(x = Count_plot, 
                   y = reorder(Description, Count_plot), 
                   fill = fill_value)) +
  geom_bar(stat = "identity", alpha = 0.9) +
  theme_bw() +
  scale_x_continuous(
    breaks = seq(from = -40, to = 20, by = 20),
    limits = c(-40, 20),
    labels = abs
  ) +
  scale_fill_gradientn(
    colours = c("#08519C", "#6BAED6", "#EFF3FF", "#FFFFFF", 
                "#FCBBA1", "#FB6A4A", "#B2182B"),
    values = scales::rescale(c(-40, -20, 0, 20)),
    name = "-log10(pvalue)"
  ) +
  theme(
    axis.text = element_text(face = "plain", color = "black", size = 11),
    axis.title = element_text(face = "bold", size = 12),
    text = element_text(family = "Arial"),
    panel.border = element_rect(color = "black", fill = NA, size = 1)
  ) +
  geom_vline(xintercept = 0, linetype = "solid", color = "black", size = 0.5) +
  xlab("Gene Count") +
  ylab("") +
  labs(title = "Cluster 2 enriched pathways")

print(p_go)
ggsave("PanelI_cluster2_GO_enrichment.pdf", p_go, width = 10, height = 8)

# ============ session info============
sink("session_info.txt")
cat("Analysis completed:", as.character(Sys.time()), "\n\n")
sessionInfo()
sink()

cat("\n========== Analysis Complete ==========\n")
cat("Session information saved to session_info.txt\n")
# =======================================================
